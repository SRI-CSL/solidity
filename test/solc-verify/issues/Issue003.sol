// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0;

/// From test/libsolidity/syntaxTests/types/cyclic_dependency_check_on_consts_good.sol

contract A {}
contract Issue003 {
    A constant B = C;
    A constant C = D;
    A constant D = E;
    A constant E = F;
    A constant F = G;
    A constant G = H;
    A constant H = I;
    A constant I = J;
    A constant J = K;
    A constant K = L;
    A constant L = M;
    A constant M = N;
    A constant N = O;
    A constant O = P;
    A constant P = Q;
    A constant Q = R;
    A constant R = S;
    A constant S = T;
    A constant T = U;
    A constant U = V;
    A constant V = W;
    A constant W = X;
    A constant X = Y;
    A constant Y = Z;
    A constant Z = BA;
    A constant BA = BB;
    A constant BB = BC;
    A constant BC = BD;
    A constant BD = BE;
    A constant BE = BF;
    A constant BF = BG;
    A constant BG = BH;
    A constant BH = BI;
    A constant BI = BJ;
    A constant BJ = BK;
    A constant BK = BL;
    A constant BL = BM;
    A constant BM = BN;
    A constant BN = BO;
    A constant BO = BP;
    A constant BP = BQ;
    A constant BQ = BR;
    A constant BR = BS;
    A constant BS = BT;
    A constant BT = BU;
    A constant BU = BV;
    A constant BV = BW;
    A constant BW = BX;
    A constant BX = BY;
    A constant BY = BZ;
    A constant BZ = CA;
    A constant CA = CB;
    A constant CB = CC;
    A constant CC = CD;
    A constant CD = CE;
    A constant CE = CF;
    A constant CF = CG;
    A constant CG = CH;
    A constant CH = CI;
    A constant CI = CJ;
    A constant CJ = CK;
    A constant CK = CL;
    A constant CL = CM;
    A constant CM = CN;
    A constant CN = CO;
    A constant CO = CP;
    A constant CP = CQ;
    A constant CQ = CR;
    A constant CR = CS;
    A constant CS = CT;
    A constant CT = CU;
    A constant CU = CV;
    A constant CV = CW;
    A constant CW = CX;
    A constant CX = CY;
    A constant CY = CZ;
    A constant CZ = DA;
    A constant DA = DB;
    A constant DB = DC;
    A constant DC = DD;
    A constant DD = DE;
    A constant DE = DF;
    A constant DF = DG;
    A constant DG = DH;
    A constant DH = DI;
    A constant DI = DJ;
    A constant DJ = DK;
    A constant DK = DL;
    A constant DL = DM;
    A constant DM = DN;
    A constant DN = DO;
    A constant DO = DP;
    A constant DP = DQ;
    A constant DQ = DR;
    A constant DR = DS;
    A constant DS = DT;
    A constant DT = DU;
    A constant DU = DV;
    A constant DV = DW;
    A constant DW = DX;
    A constant DX = DY;
    A constant DY = DZ;
    A constant DZ = EA;
    A constant EA = EB;
    A constant EB = EC;
    A constant EC = ED;
    A constant ED = EE;
    A constant EE = EF;
    A constant EF = EG;
    A constant EG = EH;
    A constant EH = EI;
    A constant EI = EJ;
    A constant EJ = EK;
    A constant EK = EL;
    A constant EL = EM;
    A constant EM = EN;
    A constant EN = EO;
    A constant EO = EP;
    A constant EP = EQ;
    A constant EQ = ER;
    A constant ER = ES;
    A constant ES = ET;
    A constant ET = EU;
    A constant EU = EV;
    A constant EV = EW;
    A constant EW = EX;
    A constant EX = EY;
    A constant EY = EZ;
    A constant EZ = FA;
    A constant FA = FB;
    A constant FB = FC;
    A constant FC = A(0x00);

    constructor() public {
        check();
    }

    function() external payable {
        check();
    }

    function check() internal pure {
        assert(address(B) == address(0x00));
        assert(address(C) == address(0x00));
        assert(address(D) == address(0x00));
        assert(address(E) == address(0x00));
        assert(address(F) == address(0x00));
        assert(address(G) == address(0x00));
        assert(address(H) == address(0x00));
        assert(address(I) == address(0x00));
        assert(address(J) == address(0x00));
        assert(address(K) == address(0x00));
        assert(address(L) == address(0x00));
        assert(address(M) == address(0x00));
        assert(address(N) == address(0x00));
        assert(address(O) == address(0x00));
        assert(address(P) == address(0x00));
        assert(address(R) == address(0x00));
        assert(address(S) == address(0x00));
        assert(address(T) == address(0x00));
        assert(address(U) == address(0x00));
        assert(address(V) == address(0x00));
        assert(address(W) == address(0x00));
        assert(address(X) == address(0x00));
        assert(address(Y) == address(0x00));
        assert(address(Z) == address(0x00));
    }
}
